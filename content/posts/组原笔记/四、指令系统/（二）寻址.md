---
title: （二）寻址
date: 2025-03-24T23:20:21.847660+08:00
tags: ['组原笔记', '四、指令系统', '（二）寻址.md']
url: /posts/KLJcHfWHmD
author: "Yan2u"
IsPost: true
ShowReadingTime: true
ShowBreadCrumbs: true
ShowPostNavLinks: true
showToc: true
TocOpen: false
ShowWordCount: true
UseHugoToc: true
---

<a href="/notes408/chapters_index"> Indexes </a> > <a href="/notes408/indexes/5RoFxkg3V7"> 组原笔记 </a> > <a href="/notes408/indexes/gOnff9ZsRW"> 四、指令系统 </a> > （二）寻址

### 0. 回顾：指令执行过程

![image-20250322231937031](https://cloudflare-imgbed-ajc.pages.dev/file/1742656792440_image-20250322231937031.png)

### 1. 指令寻址

#### 1.1. 顺序寻址

- 概念：让**程序计数器 PC 自增**，即 PC = PC + 1，指向下一条指令；
- 情景：除 JMP 指令外，其他指令执行完都会自动操作；

#### 1.2. 跳跃寻址

- 概念：通过**转移指令** `JMP x`，**显式地指定 PC 下一次该指向的位置**为 x；
- 情景：实现流程控制，函数调用等；

### 2. 数据寻址

#### 2.1. 指令格式

- 格式：`操作码 | 寻址特征码 | 形式地址 A`；
- 特征码：指示 CPU 应该选用哪种寻址方式；
- **形式地址 A**：操作码中直接给出的地址，**并不等于目标操作数的真实地址**；
- 有效地址：操作数真实地址，由 CPU **根据特征码和 A 计算得出**；
- **约定**：指令字长 = 存储字长 = 机器字长；

#### 2.2. 立即寻址

- 概念：**形式地址 A = 操作数自身**；
- 特点
  - 指令执行时不用访存，直接进行计算，**速度快**；
  - 数据 A 的范围有限（由位数决定）；

#### 2.3. 直接寻址

- 概念：**形式地址 A = 操作数内存地址**；
- 特点
  - 需要**一次访存**，较为简单；
  - 寻址范围有限（由 A 的位数决定）；
  - 地址 A 不易修改（指令在执行期间**一般不允许修改**，只读）；
- **操作数的直接地址又称为 EA；**

#### 2.4. 隐含寻址

- 概念：A 给出一个操作数的内存地址，**另一个数存储在寄存器中**（如 ACC）；
- 特点：可以缩短指令字长，其他和直接寻址相同；
- 注意
  - 寄存器中的直接就是操作数，不是地址了；

#### 2.5. 间接寻址

- 概念：**形式地址 A = 指针 P 内存地址**，指针 P 指向内存中的操作数；
- 特点
  - 需要两次访存；
  - **寻址范围较大，方便编制程序**；
  - 可扩展为**多级间接寻址**：规定最高位为 1 的都是间接地址，为 0 的才是 EA；

#### 2.6. 寄存器寻址

- 概念：形式地址 A = 寄存器地址 R，操作数存放在 R 中；
- **考研最常考的寻址方法；**
- 特点
  - 不用访存，而是访问寄存器，速度快；
  - 寄存器个数少，因此地址短，可缩短指令字长；

#### 2.7. 寄存器间接寻址

- 概念：类似 2.6，但是**寄存器 R 里存放的是 EA**；
- 特点
  - 需要访存；
  - 一般用来**编制循环程序**；

#### 2.8. 基址寻址

- 概念：**形式地址 A + 基址寄存器 BR 的值 = 有效地址**；
- 特点
  - 寻址范围大；
  - 有利于多道程序管理；
  - **BR 的值由 OS 管理**，程序执行过程中 BR 值不变，形式地址 A 可变；
  - 方便程序**分区存储和管理**；

#### 2.9. 变址寻址

- 概念：**形式地址 A + 变址寄存器 IX 的值 = 有效地址**；
- 特点
  - 寻址范围大；
  - **IX 的值由用户给定，程序执行过程中 IX 可变，形式地址 A 不变**；
  - 一般用来处理**数组问题**；
- 实例分析：循环数组访问 `A[i], i = 1 ... N-1`；
  - 数组首地址 `A`：一般由**形式地址**给出；
  - 下标（偏移）`i`：每次循环**写入 IX 寄存器**，实现连续访问；

#### 2.10. 相对寻址

- 概念：**形式地址 A + 程序计数器 PC 的值 = 有效地址**；
- 特点
  - 寻址范围较小，由 A 决定；
  - 一般用于转移指令；
  - 可实现程序浮动；

#### 2.11. 堆栈寻址

- 概念：不用给出形式地址 A (?)，默认操作数地址**存放在栈顶**，栈顶地址由固定的 **SP 寄存器**给出；

- 特点

  - 本质可视为一种寄存器间接寻址；
  - 分为**硬堆栈**和**软堆栈**两种；
    - **硬堆栈**：利用寄存器组实现堆栈，此时**不需要访存**；
    - **软堆栈**：在内存中划出一片区域实现堆栈，**需要访存**；

- **关于栈顶和 SP**

  ![image-20250322235154150](https://cloudflare-imgbed-ajc.pages.dev/file/1742658720156_image-20250322235154150.png)

  - 栈的地址是从**高地址到低地址**排列的，即栈底在高地址，固定；栈顶在低地址，可浮动；
  - SP 指向的是当前栈顶地址；
  - **进栈**：SP = SP - 1，同时将数据存放到 SP 指向的内存单元；
  - **出栈**：将 SP 指向的内存数据读出，然后 SP = SP + 1；

#### 2.12. 总结表格

- $(X)$ 表示对地址 $X$ 进行**一次间接寻址**，即**取出内存中地址 $X$ 的内存单元的值**；

|        寻址方式        |    有效地址    | 访存次数 |  应用场景/备注  |
| :--------------------: | :------------: | :------: | :-------------: |
|        立即寻址        | $A$ 表示操作数 |    0     |                 |
|        隐含寻址        |    指令规定    |    0     |  缩短指令长度   |
|        直接寻址        |     $EA=A$     |    1     |                 |
|      一次间接寻址      |    $EA=(A)$    |    2     |                 |
|      N 次间接寻址      |  $EA=((A))_N$  |  N + 1   |                 |
|   寄存器 (直接) 寻址   |    $EA=R_i$    |    0     |                 |
| 寄存器间接 (一次) 寻址 |   $EA=(R_i)$   |    1     |                 |
|        相对寻址        |  $EA=(PC)+A$   |    1     |  程序浮动/转移  |
|        基址寻址        |  $EA=(BR)+A$   |    1     |  循环/多道程序  |
|        变址寻址        |  $EA=(IX)+A$   |    1     |    数组问题     |
|   堆栈寻址 (硬堆栈)    |   $EA=(SP)$    |    0     | 硬堆栈无需寻址  |
|   堆栈寻址 (软堆栈)    |   $EA=(SP)$    |    1     | 软堆栈 1 次寻址 |

### 习题

- 1. 间址寄存器 X，形式地址 D。采用先间址后变址的寻址方式，则有效地址为

  - A. $(X)+D$；
  - B. $(X)+(D)$；
  - C. $((X)+D)$；
  - D. $((X)+(D))$；
  - **答案**：B
  - **解析**：先间址，则对 D 间接寻址得到 $(D)$，然后再变址寻址，则 $EA=(X)+(D)$；
    - 补充说明：D 选项为数据本身，即 $\mathrm{Data}=(EA)$；

- 2. 机器字长 16 位，按字节编址。转移指令 JMP 采用相对寻址，由 1 字节操作码 + 1 字节偏移量组成。假设取指令时，每取出一个字节 PC 自增 1，若某条 JMP 指令地址为 0x2000，偏移量 0x06，则该转移指令执行后，PC 指向的地址为

  - A. 0x2006；
  - B. 0x2007；
  - C. 0x2008；
  - D. 0x2009；
  - **答案**：C
  - **解析**：分析执行过程
    - 执行到该 JMP 指令时，PC = 0x2000，此时**需要取出该指令**；
    - 取出该指令后，PC = 0x2002，开始执行，即 PC = PC + Offset；
    - 所以，执行完毕后，PC = 0x2002 + 0x06 = 0x2008；

- 3. 转移指令 JMP 占 3 字节（操作码 1B + 偏移量 2B），且数据的低字节地址为字地址。设每取出一个字节，PC 自增 1；

  - 3.1. 若当前 PC = 240，要求执行完 JMP 后转移到 290，求偏移量所在两个字节的机器码；
  - 3.2. 若当前 PC = 240，要求执行完 JMP 后转移到 200，求偏移量所在两个字节的机器码；
  - **答案**：
    - 1）偏移量 47，第二字节 0010 1111，第三字节 0000 0000；
    - 2）偏移量 -43，补码形式。第二字节 1101 0101，第三字节 1111 1111；
  - **解析**：
    - 1）还是注意取指时 PC = PC + 3，即**开始执行时 PC = 243**，然后目标地址相减即可；
    - 2）同上，注意先算补码；

- 4. 变址寄存器 $(IX)=(1000)_{16}$，形式地址 $A=(2000)_{16}$，且已知三个地址的内容 $(0\mathrm{x}1000)=(2000)_{16}$，$(0\mathrm{x}2000)=(3000)_{16}$，$(0\mathrm{x}3000)=(4000)_{16}$，则变址寻址得到的操作数为

  - A. 0x1000；
  - B. 0x2000；
  - C. 0x3000；
  - D. 0x4000；
  - **答案**：D
  - **解析**：变址寻址有 $EA=(IX)+A=(3000)_{16}$，则操作数为 $(EA)=(4000)_{16}$；
